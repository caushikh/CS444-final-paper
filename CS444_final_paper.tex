\documentclass[letterpaper,10pt,titlepage]{article}

\usepackage{graphicx}                                        
\usepackage{amssymb}                                         
\usepackage{amsmath}                                         
\usepackage{amsthm}                                          

\usepackage{alltt}                                           
\usepackage{float}
\usepackage{color}
\usepackage{url}

\usepackage{hyperref}
\usepackage[vertfit]{breakurl}

\usepackage{ragged2e}
\edef\UrlBreaks{\do\-\UrlBreaks}

\usepackage{balance}
\usepackage[TABBOTCAP, tight]{subfigure}
\usepackage{enumitem}
\usepackage{pstricks, pst-node}

\usepackage{geometry}
\geometry{textheight=8.5in, textwidth=6in}

%random comment

\newcommand{\cred}[1]{{\color{red}#1}}
\newcommand{\cblue}[1]{{\color{blue}#1}}

\usepackage{hyperref}
\usepackage{geometry}

\def\name{Hari Caushik}

%pull in the necessary preamble matter for pygments output
\input{pygments.tex}

%% The following metadata will show up in the PDF properties
\hypersetup{
  colorlinks = true,
  linkcolor = black,
  urlcolor = black,
  citecolor = black,
  urlbordercolor = black,
  runbordercolor = black,
  pdfauthor = {\name},
  pdfkeywords = {CS444 ``Operating Systems II'' Final Paper},
  pdftitle = {CS 444 Final Paper},
  pdfsubject = {CS 444 Final Paper},
  pdfpagemode = UseNone
}
\urlstyle{same}

\title{Operating System Feature Comparison}
\date{December 11, 2014}
\author{Hari Caushik}

\begin{document}

\maketitle
\thispagestyle{empty}
\newpage

\tableofcontents
\newpage

\section{Processes and Threads}
\subsection{Similarities}
The information contained in the process containers for both Linux and Windows
are very similar. Specifically, all processes contain a private virtual 
address space, program code, sets of resources like opened files and signals,
and multiple threads of execution. 
\\
\linebreak
Both Linux and Windows implement user mode and kernel mode. In both operating
systems, a thread can invoke a system call that causes the kernel to execute
kernel code on behalf of the thread.

\subsection{Differences}

One fundamental difference between Linux and Windows is in process creation. 
In Linux, new processes are created by invoking two different system calls:
fork(), to create a duplicate of the current process, and exec(), to load an
executable file into the new process's address space and then execute it. 
In Windows, a call to one of the process creation functions like CreateProcess
loads an executable image file, or an .exe file, and creates the Windows
executive process object all in one.
\\

The following is a short snippet of code demonstrating the use of fork() and
then the call to execv() to create the new process with the new executable
file image in Linux.

\input{__execeg.c.tex}

Here is an example of the CreateProcess function in Windows. Notice that the
name of the module to be executed is an argument to the function whereas in
Linux, a separate exec call had to be made.

\input{__wincreateproc.c.tex}

A significant difference between Windows and Linux is the implementation of 
threads. In Linux, threads are implemented as task\_structs just like 
standard processes and simply share resources with other processes or threads.
In Windows, processes contain one or more threads and only those threads are
schedulable by the scheduler. Windows dedicates a special data structure to 
threads called the executive thread block. 
\\

In Linux, processes are schedulable and have schedulable states like running,
zombie, and interruptiple. In Windows only threads have schedulable states and
processes are not schedulable. Processes in Windows only exist to serve as a
container for resources while in Linux, processes do that as well as execute 
code.
\\

Windows also contains entities called jobs and fibers that are not supported 
by Linux. Jobs are collections of processes that can be managed as a unit.
Fibers are essentially threads that are scheduled in user space instead of
by the kernel's scheduling algorithm. 
\\

Threads in Windows are not meant to own any resources. Therefore, any object
that one thread creates belongs to its process and is therefore accessible to 
any of the other threads in that process. In Linux, the threads are represented
as standard processes and can thus own their own resources. 

\subsection{Why Similarities and Differences Exist?}

The implementation of threads in Linux is based on providing a mechanism to 
share resources between processes while in Windows, threads exist to provide
quicker execution. Thus they are represented by a separate data structure that 
is more lightweight.

\section{Memory Management}
\subsection{Similarities}
In both Linux and Windows, every process has its own virtual address space.
\\
\linebreak
Both Windows and Linux support copy-on-write paging. When an attempt is made
to modify pages that start out originally as read-only pages, the memory 
manager makes a private writable copy of the page and updates the page table 
to reference the new private page. The new page will then be paged out rather
than the original page.
\subsection{Differences}
In Windows, all user processes share the kernel's virtual memory. This is only 
accessible when running in kernel mode, but eliminates the need to change the
memory map when a system call is made. This is a trade-off between less private
address space per process and faster system calls. Linux performs a 
context-switch whenever a system call from user space traps into the kernel. 
\\
\linebreak
A consequence of this is that Windows threads can trap into the kernel and 
access other address spaces and then switch back to the original address space
before returning to user mode.
\\
\linebreak
Windows provides support for shared memory objects directly by memory 
mapped files that multiple processes can open in their virtual address space.
On the contrary, in Linux one process must allocate a shared memory segment and
then one or more other processes attach it to their address space.
\\
\linebreak
Windows and Linux processes have different amounts of their virtual address
space dedicated to kernel virtual memory. Windows dedicates 2 GB of each 4 GB
process address space for kernel virtual memory. Linux dedicates 1 GB of each
4 GB process address space for kernel virtual memory.
\\ 
\linebreak
Linux manages 3 levels of page tables to map virtual addresses into physical
addresses. These are the Page General Directory (PGD), Page Middle Directory
(PMD), and the Page Table Entry (PTE). Windows has 2 levels of page tables. 
These are the Page Directory and the Page Tables.
\subsection{Why Similarities and Differences Exist?}
Windows makes the kernel's virtual memory part of every process's virtual 
memory so that kernel code can run in kernel mode without having to perform a 
context switch. Less of a process's virtual memory is private, but it is able
to run system calls much faster. 
\section{I/O}
\subsection{Similarities}
Both Windows and Linux offer a number of similar system calls for I/O like 
open, read, write, ioctl, and close. Both operating systems view devices as 
files and control access to devices with basic file system functions.
\\
\linebreak
Both Windows and Linux provide support for asynchronous I/O. It is a method of
allowing a process to continue execution after it submits an I/O request to 
not block until data becomes available. Linux provides this functionality 
through its AIO system calls like io\_setup, io\_destroy, io\_submit,
io\_cancel, and io\_getevents. Windows provides this functionality in a number
of ways and offers a number of options to implement it. Examples include 
creating an event object when making an I/O call and waiting it at a later 
point in time, and specifying a queue to which a completion event will be 
added by the I/O manager.
\\
\linebreak
Both operating systems provide support for stacked device drivers. In Linux
they are called stacked modules. The idea is that drivers share certain 
functionalities and that multiple other drivers can be executed before 
executing the core functionality of a particular driver.
\\
\linebreak
Hibernation, or suspending to disk, is supported by both Linux and Windows.
It involves saving the computer's state to the disk and then powering down to
save power. Windows performs a number of optimizations like compression of 
memory pages and ignoring unmodified pages backed by disk.
\\
\linebreak
Both Windows and Linux support dynamically loadable modules. In Windows, these
modules are called dynamically linked libraries, or DLL's. In Linux, the 
modules are called shared objects or .so files. They allow for functions and 
data to be linked at runtime. 
\subsection{Differences}
Windows offers support for a plug and play I/O subsystem while Linux does not.
The plug-and-play is a feature that provides automatic identification of 
devices and installation of device drivers. It sends requests to a number of
different buses like PCI, USB, and SATA to register its devices. Hardware 
resources are then allocated for the device. This allows for support many more
devices than Linux.
\\
\linebreak
DLL's and .so files are very different in the way that they link dynamic 
modules. When .so files are linked to a program, the references to all the 
module's functions and data are updated to point to the actual locations in 
memory where they are placed. DLL's use a look-up table to map references to 
the module's functions and data.
\subsection{Why Similarities and Differences Exist?}
Windows supports a complex plug and play I/O subsystem to support a large 
range of devices and to simplify device driver installation for the user. 
Linux does not provide this kind of plug and play subsystem because it is 
designed for skilled programmers who can install or even write their own 
drivers for devices. They need a simple, elegant interface to write their 
drivers and load them. Not as many devices are supported, but the understanding
is that Linux programmers would be able to install the device drivers on their
own.
%input the pygmentized output of mt19937ar.c, using a (hopefully) unique name
%this file only exists at compile time. Feel free to change that.
%\input{__mt19937ar.c.tex}
\nocite{*}
\RaggedRight
\bibliographystyle{plain-annote}
\bibliography{CS444_final_paper}
\end{document}
